# Question 1

## Part a) Relational Algebra Queries

**(i) π Cust-Name (σ Balance <= 500 ∧ Branch = "Northampton"(Deposit)))**

**Solution:**
The query states that we should derive customer names with balances ≤500 (less than or equl to 500) in Northampton Branch from the Deposit table.

We see two basic operations here:

1. **Selection Operation (σ):** First, we need to  select rows from the Deposit table where: the balance is less than or equal to £500 and the branch is Northampton.

Looking at the Deposit table, the only tuples matching this condition are:
   - Northampton D244 Stephenson  £500.00
   - Northampton D477 Jutley      £375.44


2. **Projection Operation (π):** The next step is only to project the customer names that match the condition.

**Our Result:**
| Cust-Name  |
|------------|
| Stephenson |
| Jutley     |


**(ii) π Branch (σ Branch-County ≠ 'Warwickshire' ∧ Assets <= 2000000(Branch))**

**Solution**
The query states that we should derive branches where Branch-County is not Warwickshire and the assets in that branch should be leass than or equal to 2,000,000 from the Branch Relation.

We see two basic operations here:

1. **Selection Operation (σ):** We select rows from the Branch table where: Branch-County is not 'Warwickshire' and Assets are less than or equal to £2,000,000.

Looking at the Branch table, the only tuple matching this condition is Rochdale £1,000,000 Lancashire since although Birmingham and Northampton are not in Warwickshire but their assets does not meet our condition.

1. **Projection Operation (π):** The next step is only to project the Branch names that match the condition.

**Result:**
| Branch   |
|----------|
| Rochdale |


## Produce a relational expression that shows the account number and balance for all customers at the Birmingham branch with a balance greater than £400


**Solution:**
We shall perform two basic operations:

1. **Selection Operation (σ):** - First, we need to select rows from Deposit Table where: Branch is "Birmingham" and Balance is greater than £400

σ Branch = "Birmingham" ∧ Balance > 400(Deposit)

2. **Projection Operation (π):** The next step is only to project the Account number and balance

π Acc-No, Balance(σ Branch = "Birmingham" ∧ Balance > 400(Deposit)) 


## Give an outline of the main features of Relational Calculus.

Relational calculus query specifies what is to be retrieved rather than how to retrieve it.

It comes in two forms:
- Tuple Relational Calculus (TRC)
- Domain Relational Calculus (DRC)
  
Main Features:
1. **Declarative in Nature**: Relational Calculus specifies what to find without specifying how to find it.

2. **Based on Predicate Logic**: Relational Calculus uses logical expressions to define result tuples. For example, we may connect predicates by the logical connectives Ù (AND), Ú (OR), and ~ (NOT) to form compound predicates.
   
3. **Variables**: Tuple Relational Calculus uses tuple variables that range over a named relation while Domain Relational Calculus uses domain variables that range over attribute values.

4. **Quantifiers**: Quantifiers such as Existential (∃): "there exists" - used in formulae that must be true for at least one instance, and Universal (∀): "for all" - used in statements about every instance, are used to express logical conditions over sets of tuples or domains.


## Part d) Give a definition of query optimisation and outline how relational algebra can be used in the process of query optimisation.

**Definition:**
Query optimisation is the activity of choosing an efficient execution strategy for processing a query, with a goal of minimizing resource usage and response time in the process of producing desired results.

**How Relational Algebra is Used in Query Optimisation:**

1. **Query Representation:** In Query Optimisation, queries are first translated into relational algebra expressions before they are optimised for fast processing.

For example in a query like this:

```sql
SELECT Cust-Name  
FROM Deposit  
WHERE Branch = 'Birmingham' AND Balance > 400;
```
The query can be represented into a relational algebra like this `π Cust-Name (σ Balance <= 500 ∧ Branch = "Birmingham"(Deposit))` and then optimised using different logics.


2. **Transformation Rules:** By applying transformation rules, the optimiser can transform one relational algebra expression into an equivalent expression that is known to be more efficient

For example for the above Relational Algebra Expression, the optimiser can use transformational rules such as pushing selections down to perform early data filtering and thus reduce the amount of data processed later.

3. **Cost Estimation:** A DBMS may have many different ways of implementing the relational algebra operations. The aim of query optimisation is to choose the most efficient one.
To do this, it uses formulae that estimate the costs for a number of options and selects the one with the lowest cost
Different algebraic expressions are evaluated based on cardinality of each base relation, the number of blocks required to store a relation, the number of distinct values for each attribute e.t.c.

For example in our Relational Expression of finding Customers with accounts in Birmingham and having a balance greater than £400, the optimiser could have several execution plans and then would choose the best plan depending on the cost calculated based on the characteristics above.

4. **Plan Generation**: The query optimizer generates multiple execution plans from the algebraic expressions and selects the one with lowest estimated cost